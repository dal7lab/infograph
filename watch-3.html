<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>버클리 그랜드 컴플리케이션 - 디지털 트윈</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

        :root {
            --neon-cyan: #00ffff;
            --neon-gold: #ffd700;
            --dark-bg: #050505;
            --panel-bg: rgba(10, 10, 12, 0.95);
            --text-color: #e0e0e0;
        }

        body, html {
            margin: 0; padding: 0; height: 100%; width: 100%;
            background-color: var(--dark-bg);
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        /* --- TOP MENU --- */
        #top-menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 50px;
            background: var(--panel-bg);
            border-bottom: 1px solid #333;
            z-index: 10;
            display: flex; align-items: center;
            overflow-x: auto; white-space: nowrap;
            padding: 0 10px; box-sizing: border-box;
        }
        #top-menu::-webkit-scrollbar { display: none; }

        .nav-btn {
            background: transparent;
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px; margin-right: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700; font-size: 12px;
            text-transform: uppercase; transition: all 0.2s;
            flex-shrink: 0;
        }
        .nav-btn:hover { border-color: var(--neon-cyan); color: var(--neon-cyan); }
        .nav-btn.active {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-gold);
            color: var(--neon-gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        /* --- BOTTOM PANEL (Fixed Layout) --- */
        #bottom-panel {
            position: fixed; bottom: 0; left: 0; width: 100%;
            height: 24vh; /* Reduced height as requested */
            background: var(--panel-bg);
            border-top: 2px solid var(--neon-cyan);
            z-index: 10;
            color: var(--text-color);
            display: flex; flex-direction: column;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.8);
        }

        .panel-header {
            padding: 10px 20px; border-bottom: 1px solid #222;
            display: flex; justify-content: space-between; align-items: baseline;
            background: linear-gradient(90deg, rgba(0,243,255,0.05), transparent);
        }

        #panel-id { color: var(--neon-cyan); font-family: 'Rajdhani'; font-weight: 700; font-size: 12px; margin-right: 10px; letter-spacing: 1px; }
        #panel-title { color: var(--neon-gold); font-size: 16px; font-weight: 700; }

        #panel-body {
            flex: 1; padding: 15px 20px; overflow-y: auto;
            font-size: 13px; line-height: 1.7; color: #ccc;
            word-break: keep-all; text-align: justify;
        }
        
        #panel-body strong { color: #fff; font-weight: 700; }
        #panel-body ul { margin: 5px 0; padding-left: 20px; }
        #panel-body li { margin-bottom: 3px; }

        /* Scrollbar */
        #panel-body::-webkit-scrollbar { width: 5px; }
        #panel-body::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        #panel-body::-webkit-scrollbar-thumb:hover { background: var(--neon-gold); }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="top-menu">
        <!-- Buttons injected via JS -->
    </div>

    <div id="bottom-panel">
        <div class="panel-header">
            <div><span id="panel-id">MOD_00</span><span id="panel-title">시스템 초기화 중...</span></div>
        </div>
        <div id="panel-body">
            데이터를 로드하고 있습니다. 잠시만 기다려 주십시오.
        </div>
    </div>

    <script>
        // =========================================
        // 1. HANGUL DATASET (20x DETAIL)
        // =========================================
        const modulesData = [
            {
                id: "SYS_OVERVIEW",
                title: "1. 전체 조립 (Full Assembly)",
                desc: "<strong>세계에서 가장 복잡한 기계 장치의 총체적 뷰입니다.</strong><br>일반적인 그랜드 컴플리케이션 시계가 600~800개의 부품을 갖는 반면, 이 모델은 <strong>2,877개</strong>의 부품을 50.55mm 두께의 케이스 안에 초고밀도로 집약시켰습니다. 이는 단순한 적층이 아니라, 양면(Double-faced) 다이얼 설계를 통해 63개의 컴플리케이션이 하나의 통합된 기계 장치 안에서 유기적으로 맞물려 돌아가는 구조입니다. 화면의 복잡하게 얽힌 와이어프레임은 각 기능이 차지하는 물리적 공간과 에너지의 흐름을 시각화한 것입니다.",
                y: 0, range: 45
            },
            {
                id: "MOD_BASE",
                title: "2. 베이스 칼리버 (Base Caliber)",
                desc: "<strong>시계의 척추이자 심장부입니다.</strong><br>칼리버 3752의 가장 큰 기술적 특징은 '동축 리버싱 기어(Coaxial Reversing Gears)'입니다. 시계의 앞면과 뒷면을 모두 메인 다이얼로 사용하기 위해, 무브먼트 중심을 관통하는 드라이브 샤프트가 존재하며, 이 샤프트는 기계적 벡터를 180도 반전시켜 뒷면의 핸즈도 정방향(시계 방향)으로 회전하게 만듭니다. 또한 거대한 토크 부하를 견디기 위해 니켈-실버 합금 플레이트가 사용되었습니다.",
                y: -2, range: 25
            },
            {
                id: "MOD_CHINESE",
                title: "3. 중국 태음태양력 (Chinese Perpetual)",
                desc: "<strong>기계식 시계 역사상 최초의 구현입니다.</strong><br>규칙적인 양력과 달리, 중국 음력은 달의 위상(29.53일)과 태양의 공전(365.24일)이 어긋나 윤달과 설날의 날짜가 불규칙합니다. 이를 해결하기 위해 <strong>19년 주기(메톤 주기)</strong>의 데이터를 물리적으로 깎아낸 거대한 캠(Cam)을 사용합니다. 화면에 보이는 불규칙한 형태의 캠은 19년 동안 7번 돌아오는 윤달(13번째 달)을 기계가 스스로 감지하여 삽입하게 합니다.",
                y: 6, range: 20
            },
            {
                id: "MOD_TOURBILLON",
                title: "4. 3축 투르비용 (3-Axis Tourbillon)",
                desc: "<strong>중력을 3차원에서 제어하는 조속기입니다.</strong><br>일반적인 투르비용이 2차원 평면에서 회전한다면, 이 장치는 3개의 축이 각각 <strong>60초, 24초, 8초</strong> 주기로 쉴 새 없이 회전합니다. 이 복합적인 회전 벡터는 시계가 어떤 각도로 놓이든 중력 오차를 '0'으로 수렴하게 만듭니다. 내부에 보이는 구형(Spherical) 밸런스 스프링은 일반적인 평면 스프링보다 등시성이 뛰어납니다.",
                y: 12, range: 15
            },
            {
                id: "MOD_CHIME",
                title: "5. 웨스트민스터 차임 (Westminster Chime)",
                desc: "<strong>빅벤의 종소리를 손목 위에서 재현합니다.</strong><br>일반적인 미닛 리피터(2음)를 넘어선 5개의 공(Gong)과 5개의 해머를 사용합니다. '그랑 소너리' 모드에서는 매 시간과 15분마다 자동으로 4절로 구성된 멜로디를 연주합니다. 이를 위해 타종 전용 동력 배럴이 별도로 존재하며, 야간(Night Mode)에는 자동으로 소리를 차단하는 기계적 로직이 포함되어 있습니다.",
                y: -8, range: 20
            },
            {
                id: "MOD_SKY",
                title: "6. 성도 & 항성시 (Celestial Chart)",
                desc: "<strong>사용자의 머리 위 밤하늘을 실시간으로 보여줍니다.</strong><br>태양시(24시간)가 아닌 별의 주기인 <strong>23시간 56분 4초(항성시)</strong>를 기준으로 회전하는 별도 기어 트레인을 사용합니다. 사파이어 디스크 2장을 겹쳐 북반구의 별자리를 입체적으로 투영하며, 계절에 따라 변하는 별자리의 위치를 정확히 시뮬레이션합니다.",
                y: 16, range: 18
            },
            {
                id: "MOD_MOON",
                title: "7. 초정밀 문페이즈 (Precision Moonphase)",
                desc: "<strong>1,027년의 정밀도를 가집니다.</strong><br>일반적인 문페이즈가 2년 8개월마다 하루의 오차를 보이는 반면, 이 시스템은 정밀한 감속 기어비를 통해 1,027년 동안 단 하루의 오차만 발생합니다. 단순한 평면 디스크가 아닌, 회전하는 3D 구체를 통해 달의 삭망을 입체적으로 보여주며 달 표면의 크레이터까지 묘사되어 있습니다.",
                y: 20, range: 15
            },
            {
                id: "MOD_RETRO",
                title: "8. 레트로그레이드 (Retrograde Date)",
                desc: "<strong>순간적인 귀환의 미학입니다.</strong><br>날짜 바늘이 31일에 도달하면 원을 그리며 도는 것이 아니라, 순식간에 1일로 점프하여 되돌아옵니다. 이를 위해 '랙 앤 스네일(Rack & Snail)' 메커니즘이 사용되며, 복귀 시 발생하는 강력한 관성 충격을 제어하기 위해 미세한 실리콘 댐퍼가 충격을 흡수합니다.",
                y: -12, range: 18
            },
            {
                id: "MOD_SPLIT",
                title: "9. 스플릿 세컨드 (Split-Seconds)",
                desc: "<strong>시간을 쪼개는 라트라팡테(Rattrapante) 기능입니다.</strong><br>두 개의 초침이 겹쳐서 돌다가 버튼을 누르면 하나가 멈추고 다른 하나는 계속 갑니다. 다시 누르면 멈췄던 초침이 앞서가는 초침을 순식간에 따라잡습니다. 두 휠을 정밀하게 제어하는 '클램프(Clamp)'와 '하트 캠(Heart Cam)'의 유기적인 움직임이 핵심 기술입니다.",
                y: -16, range: 18
            },
            {
                id: "MOD_EQ",
                title: "10. 균시차 (Equation of Time)",
                desc: "<strong>진태양시와 평균태양시의 오차를 보여줍니다.</strong><br>지구 공전 궤도가 타원형이기 때문에 발생하는 매일의 시간 오차(-16분 ~ +14분)를 계산합니다. 화면에 보이는 <strong>'콩팥 모양(Kidney)'의 캠</strong>이 1년에 1회전하며, 캠의 굴곡을 따라 레버가 움직여 실시간 보정값을 바늘에 전달합니다.",
                y: 10, range: 18
            },
            {
                id: "MOD_PERP",
                title: "11. 그레고리 만세력 (Gregorian Perpetual)",
                desc: "<strong>400년 주기의 양력 윤년을 계산합니다.</strong><br>단순히 4년 주기만 계산하는 것이 아니라, 100년 단위의 평년 예외(2100년)와 400년 단위의 윤년 예외(2400년)까지 계산하는 위성 기어 시스템이 탑재되어 2499년까지 날짜 수정이 필요 없습니다.",
                y: 4, range: 18
            },
            {
                id: "MOD_SUN",
                title: "12. 일출/일몰 (Sunrise/Sunset)",
                desc: "<strong>계절의 변화를 기계적으로 읽어냅니다.</strong><br>사용자가 위치한 위도(Latitude)에 따라 매일 변하는 낮과 밤의 길이를 보여줍니다. 특정 위도의 연간 태양 고도 데이터를 물리적으로 깎아낸 '위도 캠'이 1년 주기로 회전하며 시각 표시 영역을 확장하거나 축소합니다.",
                y: 22, range: 15
            },
            {
                id: "MOD_WORLD",
                title: "13. 월드타임 (World Time)",
                desc: "<strong>전 세계 24개 시간대를 동시에 표시합니다.</strong><br>24개 도시명이 적힌 디스크와 24시간 링이 서로 다른 속도로 맞물려 돌아갑니다. 투명한 사파이어 디스크에 낮과 밤 영역이 음영 처리되어 있어, 직관적으로 전 세계의 낮밤을 확인할 수 있습니다.",
                y: -20, range: 20
            },
            {
                id: "MOD_ALARM",
                title: "14. 알람 시스템 (Alarm Mechanism)",
                desc: "<strong>독립적인 타종 시스템입니다.</strong><br>지정된 시간에 차임 해머를 강제로 작동시킵니다. 알람 작동 시 시계의 정확도(진동각)가 떨어지는 것을 방지하기 위해, 알람 기능만을 위한 독립적인 메인 스프링 배럴을 따로 갖추고 있어 시간 구동에 영향을 주지 않습니다.",
                y: -24, range: 20
            },
            {
                id: "MOD_SEL",
                title: "15. 기능 선택기 (Function Selector)",
                desc: "<strong>복잡성을 제어하는 변속기입니다.</strong><br>크라운(용두) 하나로 와인딩, 날짜, 시간 모드를 전환합니다. 크라운을 누를 때마다 중앙의 <strong>컬럼 휠(Column Wheel)</strong>이 회전하며 레버들의 위치를 변경, 기계적 연결 경로를 물리적으로 스위칭합니다.",
                y: -6, range: 25
            }
        ];

        // =========================================
        // 2. THREE.JS SETUP (FAIL-SAFE RENDER)
        // =========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Background is handled by CSS, keeping scene clear

        // Camera setup
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // State variables
        let targetY = 0;
        let currentY = 0;
        let targetZoom = 45;
        let currentZoom = 45;
        let isDragging = false;
        let prevMouseX = 0;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const masterGroup = new THREE.Group();
        scene.add(masterGroup);

        // =========================================
        // 3. MATERIALS & GEOMETRY (DENSE BLUEPRINT)
        // =========================================
        
        // Materials - Using Basic Materials so NO LIGHTING is needed (Fixes black screen)
        const matWireDim = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.1 });
        const matSolidDim = new THREE.MeshBasicMaterial({ color: 0x050505, transparent: true, opacity: 0.5 }); // Dark core
        const matWireActive = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const matGoldActive = new THREE.LineBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.9 });
        
        const moduleGroups = {};

        // Create dense looking mechanical parts
        function createModuleVisual(key, yPos) {
            const g = new THREE.Group();
            g.position.y = yPos;
            g.userData = { id: key };

            // 1. DENSE CORE (Stacked plates)
            for(let i=0; i<3; i++) {
                const r = 10 - (i * 0.5);
                const geo = new THREE.CylinderGeometry(r, r, 0.5, 32);
                const wire = new THREE.LineSegments(new THREE.EdgesGeometry(geo), matWireDim);
                const solid = new THREE.Mesh(geo, matSolidDim);
                solid.position.y = (i - 1) * 0.6;
                wire.position.y = (i - 1) * 0.6;
                wire.rotation.y = Math.random(); // Random rotation for complexity
                g.add(solid);
                g.add(wire);
            }

            // 2. FEATURE GEOMETRY
            let feature;
            if (key === 'MOD_TOURBILLON') {
                feature = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.SphereGeometry(5, 16, 16)), matWireDim);
            } else if (key === 'MOD_CHINESE' || key === 'MOD_EQ') {
                feature = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.TorusKnotGeometry(4, 0.8, 64, 8, 2, 3)), matWireDim);
                feature.rotation.x = Math.PI/2; feature.scale.z = 0.3;
            } else if (key === 'MOD_SKY' || key === 'MOD_MOON') {
                feature = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(6, 2)), matWireDim);
            } else {
                // Complex Gear
                feature = new THREE.Group();
                const gear = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.CylinderGeometry(7, 7, 0.5, 24)), matWireDim);
                const spokes = new THREE.LineSegments(new THREE.WireframeGeometry(new THREE.CylinderGeometry(2, 7, 0.1, 8, 1, true)), matWireDim);
                feature.add(gear, spokes);
            }
            g.add(feature);
            
            // 3. CONNECTORS (Vertical lines to simulate shafts)
            const shaft = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,-2,0), new THREE.Vector3(0,2,0)]), 
                matWireDim
            );
            g.add(shaft);

            return g;
        }

        // Build Objects
        // Compressing Y range to make it look dense (-15 to +15 approx)
        modulesData.forEach(m => {
            if(m.id !== 'SYS_OVERVIEW') {
                const obj = createModuleVisual(m.id, m.y);
                moduleGroups[m.id] = obj;
                masterGroup.add(obj);
            }
        });

        // Central Spine
        const spine = new THREE.LineSegments(
            new THREE.WireframeGeometry(new THREE.CylinderGeometry(1, 1, 60, 8)),
            new THREE.LineBasicMaterial({ color: 0x0033aa, opacity: 0.3 })
        );
        masterGroup.add(spine);

        // =========================================
        // 4. INTERACTION & UI LOGIC
        // =========================================
        const nav = document.getElementById('top-menu');
        const pId = document.getElementById('panel-id');
        const pTitle = document.getElementById('panel-title');
        const pBody = document.getElementById('panel-body');

        // Generate Buttons
        modulesData.forEach((m, idx) => {
            const btn = document.createElement('button');
            btn.className = 'nav-btn';
            // Shorten title for button
            let shortTitle = m.title.split('(')[1] ? m.title.split('(')[1].replace(')', '') : m.title.split('.')[1];
            btn.innerText = shortTitle;
            btn.onclick = () => setView(idx, btn);
            nav.appendChild(btn);
        });

        function setView(index, btn) {
            // UI Updates
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');

            const data = modulesData[index];
            pId.innerText = data.id;
            pTitle.innerText = data.title;
            pBody.innerHTML = data.desc;
            
            // Scroll text to top
            pBody.scrollTop = 0;

            // Camera Target
            targetY = data.y;
            targetZoom = data.range;

            // Highlight Logic
            const activeId = data.id;
            
            Object.keys(moduleGroups).forEach(k => {
                const grp = moduleGroups[k];
                const isActive = (activeId === 'SYS_OVERVIEW' || activeId === k);
                
                grp.traverse(c => {
                    if(c.isLineSegments || c.isLine) {
                        if(isActive) {
                            // Gold for specific selection, Cyan for overview
                            c.material = (activeId !== 'SYS_OVERVIEW') ? matGoldActive : matWireActive;
                            // Make specific selection very bright, overview slightly transparent
                            c.material.opacity = (activeId !== 'SYS_OVERVIEW') ? 1.0 : 0.4;
                        } else {
                            c.material = matWireDim;
                        }
                    }
                    if(c.isMesh) {
                        c.visible = isActive; // Show solid core only when active for contrast
                    }
                });
            });
        }

        // Input Handling (Rotate)
        document.addEventListener('mousedown', e => { if(!e.target.closest('#top-menu') && !e.target.closest('#bottom-panel')) isDragging = true; prevMouseX = e.clientX; });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', e => {
            if(isDragging) {
                masterGroup.rotation.y += (e.clientX - prevMouseX) * 0.005;
                prevMouseX = e.clientX;
            }
        });
        document.addEventListener('touchstart', e => { if(!e.target.closest('#top-menu') && !e.target.closest('#bottom-panel')) isDragging = true; prevMouseX = e.touches[0].clientX; });
        document.addEventListener('touchend', () => isDragging = false);
        document.addEventListener('touchmove', e => {
            if(isDragging) {
                masterGroup.rotation.y += (e.touches[0].clientX - prevMouseX) * 0.005;
                prevMouseX = e.touches[0].clientX;
            }
        });

        // Initial State
        setView(0, nav.firstChild);

        // =========================================
        // 5. RENDER LOOP
        // =========================================
        function animate() {
            requestAnimationFrame(animate);

            // Auto rotate slowly if not dragging
            if(!isDragging) masterGroup.rotation.y += 0.002;

            // Smooth Camera (Lerp)
            currentY += (targetY - currentY) * 0.05;
            currentZoom += (targetZoom - currentZoom) * 0.05;

            // Camera position - fixed angle looking at center
            camera.position.set(currentZoom, currentY + 10, currentZoom);
            camera.lookAt(0, currentY, 0);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

